/***************************************************************************************************
 *  Project  : Media Model
 *  Function :
 *--------------------------------------------------------------------------------------------------
 *  Author   : Yao-Chong SUN, sunyc@mail.ustc.edu.cn
 *  Company  : SUSTECH, CHINA.
 *--------------------------------------------------------------------------------------------------
 *  Copyright 2020-2022. You should have received a copy of the GNU
 *  General Public License v3.0 along with ndg2d.
 *  If not, see <http://www.gnu.org/licenses/>.
***************************************************************************************************/
#include<cmath>
#include<iostream>
//--------------------------------------------------------------------------------------------------
#include "tool_memory.h"
#include "struct_coord.h"
#include "funct_coord.h"
#include "funct_kriging.h"
//--------------------------------------------------------------------------------------------------

//--------------------------------------------------------------------------------------------------
int main(int argc, char** argv)
//--------------------------------------------------------------------------------------------------
{
  //------------------------------------------------------------------------------------------------
  if(argc!=9){
    std::cout<<"Usage of the surfmesh function :"<<std::endl;
    std::cout<<"  generate a spherical surface mesh"<<std::endl;
    std::cout<<"  ./surfmesh v1 v2 v3 v4 v5 v6 v7 v8 "<<std::endl;
    std::cout<<"     v1: lon, [-180,+180], degree"<<std::endl;
    std::cout<<"     v2: lat, [-90 ,+90 ], degree"<<std::endl;
    std::cout<<"     v3: dh , (0 ,2*pi*R), km"<<std::endl;
    std::cout<<"     v4: lon, [-90 ,+90 ], degree"<<std::endl;
    std::cout<<"     v5: lat, [-90 ,+90 ], degree"<<std::endl;
    std::cout<<"     v6: dv , (0 ,2*pi*R), km"<<std::endl;
    std::cout<<"     v7: lon, [-90 ,+90 ], degree"<<std::endl;
    std::cout<<"     v8: lat, [-90 ,+90 ], degree"<<std::endl;
    std::cout<<"        "<<std::endl;
    std::cout<<"  output: "<<std::endl;
    std::cout<<"    lon2d, lat2d "<<std::endl;
    std::cout<<"        "<<std::endl;
    std::cout<<"  example: "<<std::endl;
    std::cout<<"    $./surfmesh 10 20 0.5 15 20 0.5 10 25 "<<std::endl;
    std::cout<<"    10.5 15.5 430 "<<std::endl;
    return -1;
  }
  /*--------------------------------------------------------------------------------------
  *    v ^
  *    . |  |  |  |  |  |  |  |      x is longitude direction, and it has nlon points
  * y  6 |  |  |  |  |  |  |  |      y is latitude  direction, and it has nlat points
  * ^  5 |  |  |  |  |  |  |  |      the 2D mesh
  * |  4 |  |  |  |  |  |  |  |        mlon(nlat,nlon)
  * |  3 |  |  |  |  |  |  |  |        mlat(nlat,nlon)
  * |  2 |  |  |  |  |  |  |  |
  *    1 |  |  |  |  |  |  |  |      o(olat,olon) left-down point
  *      *---------------------->    h(hlat,hlon) right-down point
  *     o   1  2  3  4  5  6  . h    v(vlat,vlon) left-up point
  *         ----------> x            dhga great arc distance in lon direction
  *                                  dvga great arc distance in lat direction
  *-------------------------------------------------------------------------------------*/
  //--------------------------------------------------------------------------------------
  coord o0,h0,v0;
  o0.set(atof(argv[1]),atof(argv[2]),0.0,"degree","km");
  h0.set(atof(argv[4]),atof(argv[5]),0.0,"degree","km"); 
  v0.set(atof(argv[7]),atof(argv[8]),0.0,"degree","km"); 
  float dh0=5.0*atof(argv[3]);
  float dv0=5.0*atof(argv[6]);
  //--------------------------------------------------------------------------------------
  coord2D* m0=getGrid(o0,h0,v0,dh0,dv0); genElev(m0,10.0);
  //--------------------------------------------------------------------------------------
  coord o1,h1,v1;
  o1.set(atof(argv[1])+1.0,atof(argv[2])+1.0,0.0,"degree","km");
  h1.set(atof(argv[4])-1.0,atof(argv[5])+1.0,0.0,"degree","km"); 
  v1.set(atof(argv[7])+1.0,atof(argv[8])-1.0,0.0,"degree","km"); 
  float dh1=atof(argv[3]);
  float dv1=atof(argv[6]);
  //--------------------------------------------------------------------------------------
  coord2D* m1=getGrid(o1,h1,v1,dh1,dv1);
  //--------------------------------------------------------------------------------------
  kriging_ordinary(m0,m1,2.0*sqrt(dh0*dh0+dv0*dv0)); 
  //--------------------------------------------------------------------------------------
  coord2D* m=m1;
  //--------------------------------------------------------------------------------------

  //--------------------------------------------------------------------------------------
  std::cout<<m->nlon<<" "<<m->nlat<<std::endl;
  //--------------------------------------------------------------------------------------
  std::cout<<"2D longitude "<<std::endl;
  //--------------------------------------------------------------------------------------
  for(int j=0;j<m->nlat;j++)
  {
    for(int i=0;i<m->nlon;i++) std::cout<<m->v[i][j].deg.lon<<" ";
    std::cout<<std::endl;
  }
  //--------------------------------------------------------------------------------------
  //--------------------------------------------------------------------------------------
  std::cout<<"2D latitude  "<<std::endl;
  //--------------------------------------------------------------------------------------
  for(int j=0;j<m->nlat;j++)
  {
    for(int i=0;i<m->nlon;i++) std::cout<<m->v[i][j].deg.lat<<" ";
    std::cout<<std::endl;
  }
  //--------------------------------------------------------------------------------------
  std::cout<<"2D topography "<<std::endl;
  //--------------------------------------------------------------------------------------
  for(int j=0;j<m->nlat;j++)
  {
    for(int i=0;i<m->nlon;i++) std::cout<<m->v[i][j].km.e <<" ";
    std::cout<<std::endl;
  }
/*
  //--------------------------------------------------------------------------------------
  std::cout<<"2D crust1's interpolated topography "<<std::endl;
  getBndIDW(rd,pd);
  //--------------------------------------------------------------------------------------
  for(int j=0;j<p->nj;j++)
  {
    for(int i=0;i<p->ni;i++) std::cout<<p->bd3d[j][i][0] <<" ";
    std::cout<<std::endl;
  }
  //--------------------------------------------------------------------------------------
*/
  //--------------------------------------------------------------------------------------
  return 0;
  //--------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------
}
//----------------------------------------------------------------------------------------
// vim: ft=cpp:nu:nowrap
